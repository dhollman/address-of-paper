<pre class='metadata'>
Title: TODO Add Title
Shortname: D0???
Revision: 0
Audience: SG1
Status: D
Group: WG21
URL: http://wg21.link/p0????
Editor: David S Hollman, Sandia National Labs, dshollm@sandia.gov
Editor: Michael Wong, CodePlay, michael@codeplay.com
Editor: Detlef, Company, dv@vollmann.ch
Abstract: Address NB comment CH 11 in [[P0488R0]]
Date: 2016-11-09
Markup Shorthands: markdown yes
Toggle Diffs: yes
</pre>

Background {#bg}
================

National Body comment CH11 from [[P0488R0]] states:

<blockquote>

Comments: It may be useful to copy objects to a separate space for non-sequenced policies.

Proposed Change: Add explicit allowance for non-sequenced policies to copy the objects
they work on.

</blockquote>

Discussion in SG1 at Issaquah on this comment led to the suggestion that, at minimum, wording should be added to some or all of the parallel algorithms forbidding the reliance on the `addressof` operation for arguments to the function objects passed to a *parallel algorithm* [algorithms.parallel.defns].  A straw pole revealed unanimous agreement that a paper exploring this idea should be written.

In particular, it was suggested that we examine the consequences of expanding or elaborating on the clause in [algorithms.parallel.user] to include language relating to the forbidding of reliance on the `addressof` operator for arguments to certain function objects (particularly the ones called out in this section).

Approach {#appr}
========

In general, the consequences of this new restriction should be considered in the context of each  overloaded library function in [[N4604]] that takes an execution policy and at least one user-defined function object.  For many of these, we will attempt to propose at least two options, one that tries to be more conservative with respect to potential for different behavior compared to the serial (i.e., `ExecutionPolicy`-free) overload, and one that tries to be more flexible with respect to implementer freedom, but allowing for different behavior from the serial overload in some (potentially far-fetched) cases.  For some algorithms, we may also propose one or more middle-ground options.

Potential Blanket Restrictions {#blanket}
------------------------------

TODO potentially omit any discussion of copying

The primary purpose of the amendments proposed herein is to allow implementers the freedom to copy values to be passed to the user-defined function objects in order to enable certain performance optimizations.  It was generally agreed in the Issaquah discussion that this very quickly becomes counterproductive in the case of objects with non-trivial copy constructors (referencing *trivially copyable* from clause 9, paragraph 6).  Thus, a safer definition of these restrictions would restrict the `addressof` forbiddance to arguments of *trivially copyable* type.  This has the advantage that inconsistency between the 

Discussion {#discuss}
==========

`all_of` [alg.all_of] {#all_of}
---------------------

The sorts of `Predicate` function objects that could be passed to `all_of` that could rely on the address of the argument are very esoteric.  One use case that could have a `Predicate` reliant on the `addressof` the argument would be one that takes a modulus of that address to query consistency in the alignment of all items in a range (though there are probably better ways to do this).

Another use would be to check if all of the objects in a range fall in between two addresses (for instance, to copy all elements with one `memcpy` invocation).

### Conservative approach
It would potentially be sufficient to preserve the alignment of the first element in the input range as well as the relative offsets of addresses of the other elements compared to the first, though this is unlikely to be widely important.  The second possible corner case would not necessarily be addressed by this approach.

### Flexible approach
Forbid any reliance on `addressof` operations on the argument to `Predicate`.

`any_of` [alg.any_of] {#any_of}
---------------------
Similar to [[#all_of]].

`none_of` [alg.none_of] {#none_of}
---------------------
Similar to [[#all_of]].

`for_each` [alg.foreach] {#foreach}
----------------------
The function object passed to `for_each` is not included in [algorithms.parallel.user], therefore the proposed changes would not apply to `for_each`.

`find` [alg.find] {#find}
-------------------------
The algorithms `find_if` and `find_if_not` both take `Predicate` arguments.  In addition to the use cases in [[#all_of]] where the user might want to find an object with an address outside of a particular range or with a particular alignment, it may be desirable to check the containment of a non-equality-comparable ([equalitycomparable] in [[N4604]]) object in a given range.  We do not see an easy way to provide a conservative approach that preserves the correct behavior in this case.

### Conservative approach
Under the same constraints as [[#all_of]], some (but not all) possible corner cases could be handled.  There is no easy way that we can conceive of to constrain the proposed restriction to enable the non-equality-comparable containment use case.  It may be worth excluding `find_*` functions from the `addressof` restriction for this reason.

### Flexible approach
Forbid any reliance on `addressof` operations on the argument to `Predicate`.  `Predicate`s like compare-by-address (as described above) would need to be run in serial or with a layer of indirection until more user-defined flexibility on the `addressof` behavior could be added to the language by some means.

`find_*` {#find_other}
-------------------------
Other `find_*` functions raise similar concerns to those in {#find}.


TODO subsections for all of the other cases here



Proposed Wording {#word}
================

TODO wording for "blanket" change in 25.2.2
TODO wording for specific sections where blanket change doesn't make sense

